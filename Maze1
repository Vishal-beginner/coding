// Find if path exists in a maze


#include<iostream>

using namespace std;
int map [16][16];
int visited[16][16];

bool issafe(int sx, int sy)
{
if (sx>=0 && sx<16 && sy>=0 && sy<16 && visited[sy][sx]==0 && (map[sy][sx]==0 || map[sy][sx]==2 || map[sy][sx]==3 ))
    return true;
 else
     return false;
}

void setVis()
{
    for (int i = 0; i < 16; i++)
    {
        for (int j = 0; j < 16; j++)
            visited[i][j] = 0;
    }}

bool findpath(int sx,int sy,int dx,int dy)
{
	 
    if(sx==dx && sy==dy)
        return true;
    if (!issafe(sx,sy))
      {  visited[sy][sx]=1;
          return false;
      }
    if (issafe(sx,sy))
    {
        visited[sy][sx]=1;
   return findpath(sx+1,sy,dx,dy) || findpath(sx-1,sy,dx,dy) || findpath(sx,sy+1,dx,dy) ||  findpath(sx,sy-1,dx,dy);
     }
    
    
    /*
    if(issafe(sx+1,sy))
        findpath(sx+1,sy,dx,dy);
     if(issafe(sx-1,sy))
        findpath(sx-1,sy,dx,dy);
	if(issafe(sx,sy+1))
        findpath(sx,sy+1,dx,dy);
     if(issafe(sx,sy-1))
        findpath(sx,sy-1,dx,dy);
        */
}
int main(int argc, char** argv)
{
	int test_case;
	int T=10;
    int sx,sy,dx,dy;
   // memset(visited,0,sizeof(visited));
	/* 
	The freopen function below opens input.txt in read only mode and 
	sets your standard input to work with the opened file. 
	When you test your code with the sample data, you can use the function
	below to read in from the sample data file instead of the standard input.
	So. you can uncomment the following line for your local test. But you
	have to comment the following line when you submit for your scores.
	*/

	//freopen("input.txt", "r", stdin);
	

	/*
	   Read each test case from standard input.
	*/
	for(test_case = 1; test_case <= T; ++test_case)
	{
		setVis();
        int t;
        cin>>t;
        for(int i=0;i<16;++i)
        {
            string s;
            cin>>s;
        	for(int j=0;j<16;++j)
            {
           map[i][j]=s[j]-'0';
                if(map[i][j]==2)
                {
                sy=i;
                sx=j;
                }
                
                if(map[i][j]==3)
                {
                dy=i;
                dx=j;
                }
            }
        }
		/////////////////////////////////////////////////////////////////////////////////////////////
		/*
			Please, implement your algorithm from this section.
		*/
		/////////////////////////////////////////////////////////////////////////////////////////////
		bool ans;
        ans=findpath(sx,sy,dx,dy);
        
            cout<<"#"<<test_case<<" "<<int(ans)<<endl;

	}
	return 0;//Your program should return 0 on normal termination.
}
