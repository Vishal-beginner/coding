Generate a function to return the person with the largest number among those contacted the last when the emergency contact network and the person to begin contact are given.

 

 

[Example]

The emergency contact network is shown below.



 

Each circle represents an individual. The number in the circle means the numberr of the person. The red circle represents the person who begins the emergency contact. The arrow represents the contact direction. In the above example, no. 7 and no. 1 can be contacted by each other. No. 2 can contact no. 7 but not vice versa.

 

When the emergency contact network is activated, The first person no. 2 contacts no. 7 and no. 15 simultaneously. (Assume that multi-party caling is used.)

 



 

 

 

Next, no. 7 contacts no. 1 and no. 15 contacts no. 4. Assume these contacts occurs at the same time.

 



 

 

 

Next, no. 1 contacts no. 8 and no. 17 simultaneously, and no. 4 contacts no. 10 at the same time.

 

Since no.7 and no. 2 are already contacted, they are not contacted again.

 



 

 

 

 

 

The above diagram shows the condition when all contacts are completed. No. 8, no. 10 and no. 17 are the persons contact the last at the same time. Since no. 17 has the largest number among those three people, the function should return 17.

 

※Nos. 3, 6, 11, and 22 will not be contacted even when all contacts are completed.

 

 

[Constraints]

Up to 100 persons can be contacted. The numbers assigned can be between 1 ~ 100.

Like no. 5 is not shown in the above example, there can be some numbers not shown in the contact network.

If a person is to contact multiple people, the multi-party calling is always used so that they will be contacted at the same time. The time it takes to contact is always the same. (The time it takes for a person to call another is the same.)

The emergency contact network information is shared in advance, and a person already contacted is not contacted again.

As shown in the example, people like no. 3, no. 6, no. 11 and no. 22 will never be contacted.

 

 

[Input]

The first line of the input file provides the length of the input data and starting point.

The data given in next lines are interpreted as {from, to, from, to, …}. The example above will be expressed as {2, 7, 11, 6, 6, 2, 2, 15, 15, 4, 4, 2, 4, 10, 7, 1, 1, 7, 1, 8, 1, 17, 3, 22}.

Since the sequence is not significant, the following input also expresses the same emergency contact network. (There can be various inputs expressing the same emergency contact network.)

{1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 4, 2}

The same {from, to} pairs can be repeated multiple times as shown below. There is no difference of one recording or multiple recordings.

{1, 17, 1, 17, 1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 11, 6, 4, 2}

 

 

[Output]

Each of 10 lines of the output file contains the answer to each of 10 test cases. Each line begins with ‘#x’ followed by the line feed and then the answer.

 

 

[Input Example]

24 2 ← Testcase 1.
1 17 3 22 1 8 1 7 7 1 2 7 2 15 15 4 6 2 11 6 4 10 4 2

100 34 ← Testcase 2.

34 16 40 59 5 31 78 7 74 87 22 46 25 73 71 30 78 74 98 13 87 91 62 37 56 68 56 75 32 53 51 51 42 25 67 31 8 92 8 38 58 88 54 84 46 10 10 59 22 89 23 47 7 31 14 69 1 92 63 56 11 60 25 38 49 84 96 42 3 51 92 37 75 21 97 22 49 100 69 85 82 35 54 100 19 39 1 89 28 68 29 94 49 84 8 22 11 18 14 15


 … 

 


[Output Example] 

#1 17

#2 16

…











#include<iostream>
#include <vector>
#include <unordered_set>
#include <queue>
using namespace std;
#define MAXN 110
int n, start;
 
int bfs(vector<int> adj[], vector<bool> &vis){
    queue<int> q;
    q.push(start);
 
    vis[start] = true;
    int ans, max;
 
    while (!q.empty()){
        ans = -1;
        int sz = q.size();
 
        for (int i = 0; i<sz; ++i){
            int u = q.front();
            q.pop();
            ans = (u >= ans ? u : ans);
 
            for (int j : adj[u]){
                int v = j;
                if (!vis[v]){// && adj[u][v]){
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
        max = ans;
    }
    return max;
}
 
int main(int argc, char** argv)
{
    int test_case;
    int T = 10;
 
    for (test_case = 1; test_case <= T; ++test_case)
    {
        vector<bool> vis(MAXN, false);
        vector<int> adj[MAXN];//, vector<bool>(MAXN, false));   
 
        cin >> n >> start;
 
        for (int i = 0; i<n / 2; i++){
            int u, v;
            cin >> u >> v;
            //adj[u][v] = true;
            adj[u].push_back(v);
        }
        cout << "#" << test_case << " " << bfs(adj, vis) << endl;
    }
 
     
    return 0;//Your program should return 0 on normal termination.
}
